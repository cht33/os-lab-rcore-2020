### Lab4实验报告
> 计73 陈海天 2016010106

#### Q1. 详细描述第六章文档中 process::init 的执行过程。
答：
1. 首先创建了两个Thread实例，`boot_thread`(以下简称`bTH`)全为0用来表示当前进程；`temp_thread`(以下简称`tTH`)为新创建的进程，入口点为`temp_thread`函数的起始地址。
`tTH`在创建的过程中会自动新建一个栈，并在栈中压入中断帧作为初始化。创建完毕后`tTH`的`context`字段为新栈压入中断帧后的栈顶地址。
2. 接下来调用`append_initial_arguments`函数给`tTH`添加初始参数，具体作用是将中断帧的`x[11],x[12]`分别改成了`bTH`和`tTH`这两个实例在堆上的地址。
3. `bTH`调用`switch_to`函数切换进程。在函数中前半段保存了启动进程的寄存器，并且将`bTH`的`context`字段从0修改成当前栈顶。
后半段切换页表，然后切换到`tTH`的栈进行寄存器恢复。返回地址是`__trapret`，所以`switch_to`函数执行结束后跳转到`__trapret`继续执行。
4. 此时新进程的栈顶是`TrapFrame`，在`__trapret`函数中恢复所有寄存器并设置相关状态之后跳转到新进程的第一行代码开始执行。
5. 开始执行`temp_thread`函数的代码，因为第2步的设置，在第4步恢复完毕后`a0,a1`寄存器就是传入的`x[11],x[12]`两个地址。所以此时函数的两个参数分别是`bTH`和`tTH`的地址。执行完println之后由`tTH`调用`switch_to`函数切换回启动进程。
6. `switch_to`的执行过程和第3步大同小异，只是最后的返回地址是`init`函数中调用`switch_to`的返回地址。此后便回到了`init`函数中开始loop等待。


#### Q2. 给出 switch 时，重要寄存器的使用情况，画出栈的使用情况。
答：
1. 重要寄存器的使用变化情况：
   sp：旧进程调用switch的函数的栈帧顶 -> +14，分配空间保存相关寄存器的值 -> 切换到新进程的栈顶 -> -14，恢复新进程的相关寄存器。
   satp：切换为新进程的页表。
   ra：旧进程调用switch的返回地址 -> 新进程的下一步执行地址。
2. 栈的使用情况：
   ```
   // 旧进程的栈（新进程的栈完全一致）
   // 每一行表示一个字，存放着旧进程的一个寄存器的值
   -------------- <- 调用switch的函数的栈帧顶
   |     s11    |
   |     s10    |
   |     s9     |
   |     s8     |
   |     s7     |
   |     s6     |
   |     s5     |
   |     s4     |
   |     s3     |
   |     s2     |
   |     s1     |
   |     s0     |
   |     satp   |
   |     a0     | <- 栈顶
   ```